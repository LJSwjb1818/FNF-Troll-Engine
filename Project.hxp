import hxp.*;
import lime.tools.*;

import haxe.io.Path;
import sys.io.File;
import sys.FileSystem;

import lime.tools.ProjectXMLParser;
import haxe.xml.Access;

using StringTools;

class TrollEngine {
	public static var USE_EPIC_JUDGEMENT:Bool;
	public static var HSCRIPT_ALLOWED:Bool;
	public static var VIDEOS_ALLOWED:Bool;
	public static var CRASH_HANDLER:Bool;
	public static var DISCORD_ALLOWED:Bool;
	public static var MULTICORE_LOADING:Bool;
	public static var MODS_ALLOWED:Bool;

	public static var LUA_ALLOWED:Bool;
	public static var SCRIPTABLE_STATES:Bool;
	public static var PE_MOD_COMPATIBILITY:Bool;
	public static var NMV_MOD_COMPATIBILITY:Bool;

	public static var OFFICIAL_BUILD:Bool;

	public static var USING_FLXANIMATE:Bool;
	public static var USING_MOONCHART:Bool;

	public static var DO_AUTO_UPDATE:Bool;
	public static var ALLOW_DEPRECATION:Bool;
}

class Project extends HXProject 
{
	final troll = TrollEngine;
	function setupTrollEngineDefines() {
		//// TROLL ENGINE CUSTOMIZATION
		troll.USE_EPIC_JUDGEMENT = true;
		troll.HSCRIPT_ALLOWED = true;
		troll.VIDEOS_ALLOWED = (CPP);
		troll.CRASH_HANDLER = (DESKTOP);
		troll.DISCORD_ALLOWED = (DESKTOP && CPP);
		troll.MULTICORE_LOADING = (DESKTOP && CPP);
		troll.MODS_ALLOWED = (DESKTOP);
		
		// Remove if you dont want states to be modified with scripts. This only disables extension/overrides and not the HScriptedState class
		troll.SCRIPTABLE_STATES = (troll.HSCRIPT_ALLOWED);
		// Remove if you dont want Lua to be usable. Note that if you disable this, you should remove PE_MOD_COMPATIBILITY too
		troll.LUA_ALLOWED = (DESKTOP && WINDOWS && CPP);
		// Remove if you don't want Psych Engine mod compatibility -->
		troll.PE_MOD_COMPATIBILITY = (troll.LUA_ALLOWED && troll.MODS_ALLOWED);
		// Remove if you don't want NightmareVision mod compatibility-->
		troll.NMV_MOD_COMPATIBILITY = (troll.PE_MOD_COMPATIBILITY && troll.MODS_ALLOWED && troll.HSCRIPT_ALLOWED);

		// Remove if you don't want to use FlxAnimate
		troll.USING_FLXANIMATE = true;

		// Remove if you don't want to use Moonchart, which allows usage of chart formats from other rhythm games and fnf engines
		troll.USING_MOONCHART = true;
		
		// Remove if you dont want the engine to autoupdate
		troll.DO_AUTO_UPDATE = (NATIVE && DESKTOP && troll.OFFICIAL_BUILD && !DEBUG);
		
		// Remove if you don't want to allow deprecated engine features.
		// Anything marked as deprecated should be removed after a major or minor version but not after patches. (major.minor.patch)
		troll.ALLOW_DEPRECATION = !FINAL;

		////
		for (name in Type.getClassFields(troll)) {
			var v:Dynamic = Reflect.field(troll, name);
			if (v != null && v != false) {
				var value:String = (v==true) ? "" : Std.string(v);
				info(name);
				haxeDefine(name, value);
			}
		}
	}

	function shit() {
		this.meta.title = "Friday Night Funkin'";
		this.meta.packageName = "com.sowy.trollengine";
		this.meta.version = "0.2.8";
		this.meta.company = "Sowy";

		this.app.file = "Funkin";
		this.app.main = "Main";
		this.app.preloader = "flixel.system.FlxPreloader";

		this.window.width = 1280;
		this.window.height = 720;
		this.window.fps = 60;
		this.window.background = 0xFF000000;
		this.window.hardware = true;
		this.window.vsync = false;
		this.window.fullscreen = false;
		this.window.resizable = true;
		this.window.borderless = false;
		this.window.orientation = Orientation.LANDSCAPE;
		this.window.allowShaders = true;
		this.window.requireShaders = true;
		this.window.depthBuffer = false;
		this.window.stencilBuffer = false;
		this.window.antialiasing = 0;

		addIcon("art/iconOG.png");
		addIcon("art/icon64.png", 64);
		addIcon("art/icon32.png", 32);
		addIcon("art/icon16.png", 16);

		sources.push("source");

		if (DESKTOP) 
			includeAsset("alsoft.txt", (WINDOWS ? "alsoft.ini" : "alsoft.conf"));

		includeAssets("assets");
		includeAssets("default_content", "content", null, ["*.mp3"]);
		
		setupTrollEngineDefines();

		addHaxelib('openfl', "9.4.1");
		addHaxelib('lime', '8.2.2');

		addHaxelib('flixel', "5.5.0");
		addHaxelib("flixel-ui", "2.6.1");
		addHaxelib("flixel-addons", "3.2.3");

		if (troll.USING_FLXANIMATE) {
			addHaxelib("flxanimate", "3.0.4");
			sources.push("flxAnimateShadow"); // Remove if FlxAnimate updates and lets you write your own code to determine how filesystem shit is gotten
		}

		if (troll.USING_MOONCHART) {			
			addHaxelib("moonchart", "0.4.0");
		}

		if (troll.DISCORD_ALLOWED) {
			addHaxelib("hxdiscord_rpc");
		}

		if (troll.VIDEOS_ALLOWED) {
			// You can replace with hxcodec if you're stubborn and dont wanna use newer and better libs
			addHaxelib("hxvlc", "1.6.1");
		}

		if (troll.LUA_ALLOWED) {
			addHaxelib("linc_luajit");
			haxeDefine("LINC_LUA_RELATIVE_DYNAMIC_LIB");
		}

		if (troll.HSCRIPT_ALLOWED) {
			addHaxelib("hscript");
			define("hscriptPos");
			addHaxeMacro("include('funkin')");
		}

		if (troll.MULTICORE_LOADING && false) {
			define("traceLoading");
			define("loadBenchmark");
		}

		/*
		if (SWITCH) {
			addHaxelib("faxe");
		}
		*/

		/*
		if (DEBUG && !telemetry) {
			addHaxelib("hxcpp-debug-server")
		}
		*/

		if (troll.CRASH_HANDLER) {
			haxeDefine("HXCPP_STACK_TRACE");
			haxeDefine("HXCPP_CHECK_POINTER");
			haxeDefine("HXCPP_STACK_LINE");
			haxeDefine("openfl-enable-handle-error");
		}
	}

	// Platform Type
	final DESKTOP:Bool;
	final MOBILE:Bool;
	final WEB:Bool;
	final CONSOLE:Bool;

	// Language
	//final HTML5:Bool;
	final HASHLINK:Bool;
	final NEKO:Bool;
	final JAVA:Bool;
	final NODEJS:Bool;
	final CSHARP:Bool;
	final CPP:Bool;

	final NATIVE:Bool;

	// Platform
	final WINDOWS:Bool;
	final AIR:Bool;
	final ANDROID:Bool;
	final BLACKBERRY:Bool;
	final CONSOLE_PC:Bool;
	final FIREFOX:Bool;
	final FLASH:Bool;
	final HTML5:Bool;
	final IOS:Bool;
	final LINUX:Bool;
	final MAC:Bool;
	final PS3:Bool;
	final PS4:Bool;
	final TIZEN:Bool;
	final VITA:Bool;
	final WEB_ASSEMBLY:Bool;
	final WEBOS:Bool;
	final WIIU:Bool;
	final XBOX1:Bool;
	final EMSCRIPTEN:Bool;
	final TVOS:Bool;
	final CUSTOM:Bool;

	//
	final DEBUG:Bool;
	final FINAL:Bool;
	final RELEASE:Bool;

	public function new() {
		super();

		DESKTOP = platformType == PlatformType.DESKTOP;
		MOBILE = platformType == PlatformType.MOBILE;
		WEB = platformType == PlatformType.WEB;
		CONSOLE = platformType == PlatformType.CONSOLE;
	
		WINDOWS = target == Platform.WINDOWS;
		AIR = target == Platform.AIR;
		ANDROID = target == Platform.ANDROID;
		BLACKBERRY = target == Platform.BLACKBERRY;
		CONSOLE_PC = target == Platform.CONSOLE_PC;
		FIREFOX = target == Platform.FIREFOX;
		FLASH = target == Platform.FLASH;
		HTML5 = target == Platform.HTML5;
		IOS = target == Platform.IOS;
		LINUX = target == Platform.LINUX;
		MAC = target == Platform.MAC;
		PS3 = target == Platform.PS3;
		PS4 = target == Platform.PS4;
		TIZEN = target == Platform.TIZEN;
		VITA = target == Platform.VITA;
		WEB_ASSEMBLY = target == Platform.WEB_ASSEMBLY;
		WEBOS = target == Platform.WEBOS;
		WIIU = target == Platform.WIIU;
		XBOX1 = target == Platform.XBOX1;
		EMSCRIPTEN = target == Platform.EMSCRIPTEN;
		TVOS = target == Platform.TVOS;
		CUSTOM = target == Platform.CUSTOM;	

		// HTML5 = WEB;
		HASHLINK = targetFlags.exists("hl");
		NEKO = targetFlags.exists("neko");
		JAVA = targetFlags.exists("java");
		NODEJS = targetFlags.exists("nodejs");
		CSHARP = targetFlags.exists("cs");
		CPP = !(HTML5 || HASHLINK || NEKO || JAVA || NODEJS || CSHARP);
		NATIVE = CPP || JAVA || CSHARP || HASHLINK || NEKO; // php, cpp, java, python, macro, cs, lua, hl, neko

		if (debug)
			DEBUG = true;
		else if (targetFlags.exists("final"))
			FINAL = true;
		else
			RELEASE = true;

		info('Compiling for $platformType, $target');
		shit();
	}

	function define(name:String, value:String = "") {
		defines.set(name, value);
		haxedefs.set(name, value);
	}

	function haxeDefine(name:String, value:String = "") {
		haxedefs.set(name, value);
	}

	function includeAsset(path:String = "", rename:String = "", type:AssetType = null, embed:Null<Bool> = null, setDefaults:Bool = true) {
		var ass = new Asset(path, rename, type, embed, setDefaults);
		assets.push(ass);
		return ass;
	}

	function addIcon(path:String, size:Int = 0, priority:Int = 0) {
		var icon = new Icon (path, size, priority);
		icons.push (icon);
		return icon;
	}

	function addHaxelib(name:String, version:String = ""):Haxelib {
		var hl = new Haxelib(name, version);
		this.haxelibs.push(hl);
		return hl;
	}

	function addHaxeFlag(value:String):Void {
		this.haxeflags.push(value);
	}

	function addHaxeMacro(value:String):Void {
		addHaxeFlag('--macro ${value}');
	}

	/** Display an error message. This should also stop the building process **/
	function error(message:String) {
		Log.error(message);
	}

	/** Display an info message. This should not stop the building process **/
	function info(message:String) {
		Log.info(message);
	}

	/** Return the inner contents of a file as a string **/
	function getFileContent(relativePath:String):Null<String> {
		var filePath = Path.normalize(Sys.getCwd()) + '/$relativePath';                
		return FileSystem.exists(filePath) ? File.getContent(filePath) : null;
	}
}